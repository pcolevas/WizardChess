#include <Arduino.h>
#include <stdio.h>
#include <stdlib.h>
#include "driver/i2s.h"                       // Library of I2S routines, comes with ESP32 standard install
#include "WavData.h" 
#include <AccelStepper.h>
#include <MultiStepper.h>
#include <WiFi.h>
#include <WebServer.h>

/*/////////////////////////////////////////////////////////////////////////////
                                      VARIABLES
/////////////////////////////////////////////////////////////////////////////*/
float l = 605;
float p = 30;
float n = 360;
float m = 360;
int speed = 700; 
float homeX = 1860;
float homeY = 1275;
float captXL = 50; 
float captXR = 3700; 


float xArray[8] = {l, l+(1.*n), l+(2.*n), l+(3.*n), l+(4.*n), l+(5.*n), l+(6.*n), l+(7.*n)};
float yArray[8] = {p, p+(1*n), p+(2*n), p+(3*n), p+(4*n), p+(5*n), p+(6*n), p+(7*n)};

// step size 
const int step_x = 375 ; 
const int step_y = 375 ; 

//State Variables 
bool splice = 1;
bool conv = 0; 
bool mov = 0; 
bool usearray = 0; 
bool start;

// define pins
const int stepPinA = 21;
const int dirPinA = 47;
const int stepPinB = 48;
const int dirPinB = 45;
const int limitSwitch_x = 0;
const int limitSwitch_y = 35;
const int emag = 36 ; 
const int led_G = 8; 
const int led_R = 17;
const int led_B = 18;

//message processing variables
String in ; 
String initLet;
String initNum;
String finLet;
String finNum;
String capt;
int transX1;
int transY1;
int transX2;
int transY2;
float initX;
float initY;
float finX;
float finY; 
bool captBool; 
int turnCounter = 1; 

//WIFI Setup
const char* ssid = "SDNet";
const char* password = "CapstoneProject";
String message = "";
WebServer server(80);



// instantiate stepper motor objects
AccelStepper A(AccelStepper::DRIVER, stepPinA, dirPinA);
AccelStepper B(AccelStepper::DRIVER, stepPinB, dirPinB);

//Audio
static const i2s_port_t i2s_num = I2S_NUM_0;  // i2s port number

    struct WavHeader_Struct
    {
      //   RIFF Section    
      char RIFFSectionID[4];      // Letters "RIFF"
      uint32_t Size;              // Size of entire file less 8
      char RiffFormat[4];         // Letters "WAVE"
      
      //   Format Section    
      char FormatSectionID[4];    // letters "fmt"
      uint32_t FormatSize;        // Size of format section less 8
      uint16_t FormatID;          // 1=uncompressed PCM
      uint16_t NumChannels;       // 1=mono,2=stereo
      uint32_t SampleRate;        // 44100, 16000, 8000 etc.
      uint32_t ByteRate;          // =SampleRate * Channels * (BitsPerSample/8)
      uint16_t BlockAlign;        // =Channels * (BitsPerSample/8), effectivly the size of a single sample for all chans.
      uint16_t BitsPerSample;     // 8,16,24 or 32
    
      // Data Section
      char DataSectionID[4];      // The letters "data"
      uint32_t DataSize;          // Size of the data that follows
    }WavHeader;
    

// speaker settings
#define USE_I2S_SPEAKER_OUTPUT
#define I2S_SPEAKER_SERIAL_CLOCK GPIO_NUM_46
#define I2S_SPEAKER_LEFT_RIGHT_CLOCK GPIO_NUM_3
#define I2S_SPEAKER_SERIAL_DATA GPIO_NUM_9
// Shutdown line if you have this wired up or -1 if you don't
#define I2S_SPEAKER_SD_PIN -1

static const i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),
    .sample_rate = 44100,                            // Note, this will be changed later
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
    .communication_format = (i2s_comm_format_t)(I2S_COMM_FORMAT_STAND_I2S),
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,       // high interrupt priority
    .dma_buf_count = 8,                             // 8 buffers
    .dma_buf_len = 1024,                            // 1K per buffer, so 8K of buffer space
    .use_apll=0,
    .tx_desc_auto_clear= true, 
    .fixed_mclk=-1    
};

// These are the physical wiring connections to our I2S decoder board/chip from the esp32, there are other connections
// required for the chips mentioned at the top (but not to the ESP32), please visit the page mentioned at the top for
// further information regarding these other connections.

static const i2s_pin_config_t pin_config = {
    .bck_io_num = I2S_SPEAKER_SERIAL_CLOCK,
    .ws_io_num = I2S_SPEAKER_LEFT_RIGHT_CLOCK,
    .data_out_num = I2S_SPEAKER_SERIAL_DATA,
    .data_in_num = I2S_PIN_NO_CHANGE};

/*///////////////////////////////////////////////////////////////////////
                                    FUNCTIONS 
///////////////////////////////////////////////////////////////////////*/ 

void handlePost() {
  if (server.method() == HTTP_POST) {
    message = server.arg("message");
    Serial.print(message); 
    server.send(200);
  }
}

void green(bool state) { 

      digitalWrite(led_G,LOW);
      digitalWrite(led_R,LOW);
      digitalWrite(led_B,LOW);

  
    if(state){
      digitalWrite(led_G,HIGH);
    }
    else if(!state){
      digitalWrite(led_G,LOW);
    }
  
}

void white(bool state) { 
  
    if(state){
      digitalWrite(led_G,HIGH);
      digitalWrite(led_R,HIGH);
      digitalWrite(led_B,HIGH);
    }
    else if(!state){
      digitalWrite(led_G,LOW);
      digitalWrite(led_R,LOW);
      digitalWrite(led_B,LOW);
    }
  
}

void red(bool state) { 

      digitalWrite(led_G,LOW);
      digitalWrite(led_R,LOW);
      digitalWrite(led_B,LOW);
  
    if(state){
      digitalWrite(led_R,HIGH);
    }
    else if(!state){
      digitalWrite(led_R,LOW);
    }
  
}

void blue(bool state){

    digitalWrite(led_G,LOW);
    digitalWrite(led_R,LOW);
    digitalWrite(led_B,LOW);
  
    if(state){
      digitalWrite(led_B,HIGH);
    }
    else if(!state){
      digitalWrite(led_B,LOW);
    }
  
}

// Turn Magnet ON
void magnetOn(){
    digitalWrite(emag,HIGH); 
}

// Turn Magnet OFF
void magnetOff(){
  digitalWrite(emag,LOW) ; 
}

//Stops both motors immediately
void stopBoth(){
  A.stop();
  B.stop();
}

//USED ONLY FOR INITIALIZATION//
void negX(){
  A.setSpeed(-speed);
  B.setSpeed(-speed);
  A.runSpeed();
  B.runSpeed();
}

//USED ONLY FOR INITIALIZATION//
void negY(){
  
  A.setSpeed(-speed);
  B.setSpeed(speed);
  A.runSpeed();
  B.runSpeed();
}

//Sets the current position as zero for both A and B motors
void currentPositionZero(){
   A.setCurrentPosition(0.0);
   B.setCurrentPosition(0.0);
}

// moveDeltaX and moveDeltaY ONLY complete lateral and vertical movements along respective axes 
void moveDeltaX(float delta){

   A.moveTo(delta);
   B.moveTo(delta);
   A.setSpeed(speed);
   B.setSpeed(speed);

   while(A.distanceToGo()!=0 && B.distanceToGo()!=0){
      A.runSpeedToPosition();
      B.runSpeedToPosition();
      }

 
}

void moveDeltaY(float delta){

   A.moveTo(delta);
   B.moveTo(-1.0*(delta));
   A.setSpeed(speed);
   B.setSpeed(speed);

   while(A.distanceToGo()!=0 && B.distanceToGo()!=0){
      A.runSpeedToPosition();
      B.runSpeedToPosition();
      }

 
}

void diagCase1(float delta){

    A.moveTo(delta);
    A.setSpeed(speed);

    while(A.distanceToGo()!=0){
      A.runSpeedToPosition();
    }
}

void diagCase2(float delta){

    B.moveTo(-1.0*delta);
    B.setSpeed(speed);

    while(B.distanceToGo()!=0){
      B.runSpeedToPosition();
    }
}

void diagCase3(float delta){

    A.moveTo(-1.0*delta);
    A.setSpeed(speed);

    while(A.distanceToGo()!=0){
      A.runSpeedToPosition();
    }
}

void diagCase4(float delta){

    B.moveTo(delta);
    B.setSpeed(speed);

    while(B.distanceToGo()!=0){
      B.runSpeedToPosition();
    }
}

void initialize(){
  //uses the state variable 'start' to turn thes function on or off
  if(start){
   stopBoth();
   while(digitalRead(limitSwitch_y)){
      negY();
      }
   stopBoth();
   delay(100);
   while(digitalRead(limitSwitch_x)){
      negX();}
      stopBoth();
   currentPositionZero();
   start = 0;
   }  
}

void moveDiagonally(float deltx, float delty){

    float delta = sqrt( (sq(deltx)) + (sq(delty)) ) ; 

    if ( ((deltx) > 0) && ((delty > 0) ) ){

        diagCase1(delta*1.45);
        magnetOff();
      
    }
    else if( ((deltx) < 0) && ((delty > 0) ) ){

        diagCase2(delta*1.45);
        magnetOff();
    }
    else if( ((deltx) < 0) && ((delty < 0) ) ){

        diagCase3(delta*1.45);
        magnetOff(); 
    }
    else if( ((deltx) > 0) && ((delty < 0) ) ){

        diagCase4(delta*1.45);
        magnetOff();
    }

  
}

bool isEvenTurn(){

      if (turnCounter % 2)
    {
        return 1; 
    }
    else
    {
        return 0; 
    }
}

void move(float x1, float y1,float x2, float y2){


  float targetx = x2-x1;
  float targety = y2-y1; 

  currentPositionZero(); 
  moveDeltaY(targety);  
  currentPositionZero();
  moveDeltaX(targetx);
  currentPositionZero();
  //arives at point (x,y) 
  
}

void captChessMove(float x1, float y1, float x2, float y2){


      red(1);
      int distToJail; 

        if(isEvenTurn()){

          if(transY2!=7){

                //float captPosX = x2 + distToJail; 
                float captPosY = y2 + 190 ; 

                  move(homeX, homeY, x2, y2);
                  magnetOn();
                  delay(500);

                  move(x2,y2, captXR, y2+190);
                  delay(100);
                  magnetOff(); 

                  // move back to piece being moved      
                  move(captXR,captPosY, x1, y1);
                        

               }
              else if(transY2=7){

               //float captPosX = x2 + distToJail; 
                float captPosY = y2 - 190 ; 

                  move(homeX, homeY, x2, y2);
                  magnetOn();
                  delay(500);

                  move(x2,y2, captXR, y2-190);
                  delay(100);
                  magnetOff(); 

                  // move back to piece being moved      
                  move(captXR,captPosY, x1, y1);

              }}
        else if(!isEvenTurn()){

            
              if(transY2!=7){

                  //float captPosX = x2 + distToJail; 
                  float captPosY = y2 + 190 ; 

                  move(homeX, homeY, x2, y2);
                  magnetOn();
                  delay(500);

                  move(x2,y2, captXL, y2+190);
                  delay(100);
                  magnetOff(); 

                  // move back to piece being moved      
                  move(captXL,captPosY, x1, y1);
                

              }
          else if(transY2=7){

              //float captPosX = x2 + distToJail; 
                  float captPosY = y2 + 190 ; 

                  move(homeX, homeY, x2, y2);
                  magnetOn();
                  delay(500);

                  move(x2,y2, captXL, y2-190);
                  delay(100);
                  magnetOff(); 

                  // move back to piece being moved      
                  move(captXL,captPosY, x1, y1);

          }}


     
    
}
  
void chessMove(float x1, float y1, float x2, float y2){

    if(mov){

        float deltX = x2-x1 ;
        float deltY = y2-y1 ;
        float xhalfstep = deltX/2;
        float yhalfstep = deltY/2;
        
        if(captBool){
          captChessMove(x1,y1,x2,y2);}
        else if(!captBool){
          move(homeX, homeY, x1, y1);};

        white(1);
        magnetOn();
        delay(500);
        

        if(transX1 == transX2){

          moveDeltaY(deltY);
          delay(500);
          magnetOff();
          
          if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
          else{ move(x2,y2,homeX,homeY); }

        }
        else if(transY1 == transY2){

          moveDeltaX(deltX);
          delay(500);
          magnetOff();
          
          if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
          else{ move(x2,y2,homeX,homeY); }  

        }
        else if( abs(transX1-transX2) == abs(transY1-transY2) ){
          
            moveDiagonally(deltX,deltY);
            white(1);
            start=1; 
            initialize();   
            move(0,0,homeX,homeY); 


        }
        else if( ( (abs(transX1-transX2) == 1) && (abs(transY1-transY2) == 2) ) || ( (abs(transY1-transY2) == 1) && (abs(transX1-transX2) == 2) ) ){

              if( (transX2-transX1)==1 && (transY2-transY1)==2){
                  moveDeltaX(xhalfstep);
                  currentPositionZero();
                  moveDeltaY(deltY);
                  currentPositionZero();
                  moveDeltaX(xhalfstep+50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2+50,y2,homeX,homeY); }    
              }
              else if((transX2-transX1)==-1 && (transY2-transY1)==2){
                  moveDeltaX(xhalfstep);
                  currentPositionZero();
                  moveDeltaY(deltY);
                  currentPositionZero();
                  moveDeltaX(xhalfstep-50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2-50,y2,homeX,homeY); }    
              }
              else if((transX2-transX1)==1 && (transY2-transY1)==-2){
                  moveDeltaX(xhalfstep);
                  currentPositionZero();
                  moveDeltaY(deltY);
                  currentPositionZero();
                  moveDeltaX(xhalfstep+50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2+50,y2,homeX,homeY); }   
              }
              else if((transX2-transX1)==-1 && (transY2-transY1)==-2){
                  moveDeltaX(xhalfstep);
                  currentPositionZero();
                  moveDeltaY(deltY);
                  currentPositionZero();
                  moveDeltaX(xhalfstep-50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2-50,y2,homeX,homeY); }  
              }
              else if((transX2-transX1)==2 && (transY2-transY1)==1){
                  moveDeltaY(yhalfstep);
                  currentPositionZero();
                  moveDeltaX(deltX);
                  currentPositionZero();
                  moveDeltaY(yhalfstep+50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2,y2+50,homeX,homeY); }  
              }
              else if((transX2-transX1)==2 && (transY2-transY1)==-1){
                  moveDeltaY(yhalfstep);
                  currentPositionZero();
                  moveDeltaX(deltX);
                  currentPositionZero();
                  moveDeltaY(yhalfstep-50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2,y2-50,homeX,homeY); }
              }
              else if((transX2-transX1)==-2 && (transY2-transY1)==1){
                  moveDeltaY(yhalfstep);
                  currentPositionZero();
                  moveDeltaX(deltX);
                  currentPositionZero();
                  moveDeltaY(yhalfstep+50);
                  delay(500);
                  magnetOff();
                  white(1);  
                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2,y2+50,homeX,homeY); }
              }
              else if((transX2-transX1)==-2 && (transY2-transY1)==-1){
                  moveDeltaY(yhalfstep);
                  currentPositionZero();
                  moveDeltaX(deltX);
                  currentPositionZero();
                  moveDeltaY(yhalfstep-50);
                  delay(500);
                  white(1);  
                  magnetOff();

                  if(turnCounter%4==0){
                    start=1;
                    initialize();   
                    move(0,0,homeX,homeY); 
                  }
                  else{ move(x2,y2-50,homeX,homeY); }
                  
                  
              }

        }
    white(1); 
    mov=0; 
    turnCounter=turnCounter+1; 

    }
}

void convert(){
  if(conv){

      // Use these chars to convert message to corrdinates
      String A = "A";
      String B = "B";
      String C = "C";
      String D = "D";
      String E = "E";
      String F = "F";
      String G = "G";
      String H = "H";

      String one = "1";
      String two = "2";
      String three = "3";
      String four = "4";
      String five = "5";
      String six = "6";
      String seven = "7";
      String eight = "8";
     
      

      if(initLet == A){
         transX1 = 0 ;
        
      }
      else if(initLet==B){
         transX1 = 1 ;
       
      }
      else if(initLet==C){
        transX1 = 2 ;
        
      }
      else if(initLet==D){
        transX1 = 3 ;
        
      }
      else if(initLet==E){
        transX1 = 4 ;
        
      }
      else if(initLet==F){
        transX1 = 5 ;
         
      }
      else if(initLet==G){
       transX1 = 6 ;
         
      }
      else if(initLet==H){
       transX1 = 7 ;
        
      }


      if(initNum==one){
        transY1 = 0 ; 
      }
      else if(initNum==two){
       transY1 = 1 ;
         
      }
      else if(initNum==three){
       transY1 = 2 ;
        
      }
      else if(initNum==four){
        transY1 = 3 ;
        
      }
      else if(initNum==five){
        transY1 = 4 ;
        
      }
      else if(initNum==six){
        transY1 = 5 ;
        
      }
      else if(initNum==seven){
        transY1 = 6 ;
        
      }
      else if(initNum==eight){
        transY1 = 7 ;
        
      }

      if(finLet==A){
        transX2 = 0 ; 
        
      }
      else if(finLet==B){
        transX2 = 1 ;
        
      }
      else if(finLet==C){
        transX2 = 2 ;
        
      }
      else if(finLet==D){
        transX2 = 3 ;
         
      }
      else if(finLet==E){
        transX2 = 4 ;
        
      }
      else if(finLet==F){
        transX2 = 5 ;
         
      }
      else if(finLet==G){
        transX2 = 6 ;
         
      }
      else if(finLet==H){
       transX2 = 7 ;
         
      }


      if(finNum==one){
        transY2 = 0 ; 
      }
      else if(finNum==two){
        transY2 = 1 ;
        
      }
      else if(finNum==three){
        transY2 = 2 ;
        
      }
      else if(finNum==four){
        transY2 = 3 ;
        
      }
      else if(finNum==five){
        transY2 = 4 ;
        
      }
      else if(finNum==six){
        transY2 = 5 ;
        
      }
      else if(finNum==seven){
        transY2 = 6 ;
        
      }
      else if(finNum==eight){
        transY2 = 7 ;
        
      }

       
    conv = 0; 
    mov = 1; 
    usearray=1;
  
  }
}

void spliceMessage(){

    
    if(splice){
        static unsigned int message_pos = 0;
        initLet = message[0];
        initNum = message[1];
        finLet = message[2] ;
        finNum = message[3]; 
        capt = message[4];

        splice = 0 ;
        conv = 1;
    }
}

void useArray(){

  if(usearray){

  initX = xArray[transX1];
  initY = yArray[transY1];
  finX = xArray[transX2];
  finY = yArray[transY2];
  
  }
  usearray = 0;
}

void convertCapt(String capt){

    if (capt=="0")
    {
      captBool = 0;
    }
    else if(capt=="1")
    {
      captBool = 1;
    }
    
}

void PrintData(const char* Data,uint8_t NumBytes)
{
    for(uint8_t i=0;i<NumBytes;i++)
      Serial.print(Data[i]); 
      Serial.println();  
}

bool ValidWavData(WavHeader_Struct* Wav)
{
  
  if(memcmp(Wav->RIFFSectionID,"RIFF",4)!=0) 
  {    
    Serial.print("Invlaid data - Not RIFF format");
    return false;        
  }
  if(memcmp(Wav->RiffFormat,"WAVE",4)!=0)
  {
    Serial.print("Invlaid data - Not Wave file");
    return false;           
  }
  if(memcmp(Wav->FormatSectionID,"fmt",3)!=0) 
  {
    Serial.print("Invlaid data - No format section found");
    return false;       
  }
  if(memcmp(Wav->DataSectionID,"data",4)!=0) 
  {
    Serial.print("Invlaid data - data section not found");
    return false;      
  }
  if(Wav->FormatID!=1) 
  {
    Serial.print("Invlaid data - format Id must be 1");
    return false;                          
  }
  if(Wav->FormatSize!=16) 
  {
    Serial.print("Invlaid data - format section size must be 16.");
    return false;                          
  }
  if((Wav->NumChannels!=1)&(Wav->NumChannels!=2))
  {
    Serial.print("Invlaid data - only mono or stereo permitted.");
    return false;   
  }
  if(Wav->SampleRate>48000) 
  {
    Serial.print("Invlaid data - Sample rate cannot be greater than 48000");
    return false;                       
  }
  if(Wav->BitsPerSample!=16) 
  {
    Serial.print("Invlaid data - Only 16 bits per sample permitted.");
    return false;                        
  }
  return true;
}

void DumpWAVHeader(WavHeader_Struct* Wav)
{
  if(memcmp(Wav->RIFFSectionID,"RIFF",4)!=0)
  {
    Serial.print("Not a RIFF format file - ");    
    PrintData(Wav->RIFFSectionID,4);
    return;
  } 
  if(memcmp(Wav->RiffFormat,"WAVE",4)!=0)
  {
    Serial.print("Not a WAVE file - ");  
    PrintData(Wav->RiffFormat,4);  
    return;
  }  
  if(memcmp(Wav->FormatSectionID,"fmt",3)!=0)
  {
    Serial.print("fmt ID not present - ");
    PrintData(Wav->FormatSectionID,3);      
    return;
  } 
  if(memcmp(Wav->DataSectionID,"data",4)!=0)
  {
    Serial.print("data ID not present - "); 
    PrintData(Wav->DataSectionID,4);
    return;
  }  
  // All looks good, dump the data
  Serial.print("Total size :");Serial.println(Wav->Size);
  Serial.print("Format section size :");Serial.println(Wav->FormatSize);
  Serial.print("Wave format :");Serial.println(Wav->FormatID);
  Serial.print("Channels :");Serial.println(Wav->NumChannels);
  Serial.print("Sample Rate :");Serial.println(Wav->SampleRate);
  Serial.print("Byte Rate :");Serial.println(Wav->ByteRate);
  Serial.print("Block Align :");Serial.println(Wav->BlockAlign);
  Serial.print("Bits Per Sample :");Serial.println(Wav->BitsPerSample);
  Serial.print("Data Size :");Serial.println(Wav->DataSize);
}

void play(const unsigned char *WavFile){
  unsigned const char* TheData;
  uint32_t DataIdx=0;                           // index offset into "TheData" for current  data t send to I2S
  memcpy(&WavHeader,WavFile,44);                     // Copy the header part of the wav data into our structure
  DumpWAVHeader(&WavHeader);                          // Dump the header data to serial, optional!
  if(ValidWavData(&WavHeader))
  {
    i2s_set_sample_rates(i2s_num, WavHeader.SampleRate);      //set sample rate 
    TheData=WavFile+44;                                     // set to start of data  

    while (DataIdx<=WavHeader.DataSize){
      uint8_t Mono[4];                             // This holds the data we actually send to the I2S if mono sound
      const unsigned char *Data;                   // Points to the data we are going to send                                              
      size_t BytesWritten;                         // Returned by the I2S write routine, we are not interested in it

      // The WAV Data could be mono or stereo but always 16 bit, that's a data size of 2 byte or 4 bytes  
      // Unfortunatly I2S only allows stereo, so to send mono we have to send the mono sample on both left and right
      // channels. It's a bit of a faf really!
      if(WavHeader.NumChannels==1)     // mono
      {
        Mono[0]=*(TheData+DataIdx);                 // copy the sample to both left and right samples, this is left
        Mono[1]=*(TheData+DataIdx+1);      
        Mono[2]=*(TheData+DataIdx);                 // Same data to the right channel
        Mono[3]=*(TheData+DataIdx+1);     
        Data=Mono;    
      }
      else                            // stereo
        Data=TheData+DataIdx;
      
      i2s_write(i2s_num,Data,4,&BytesWritten,portMAX_DELAY); 
      DataIdx+=WavHeader.BlockAlign;                            // increase the data index to next next sample
    }
  }
}



/*/////////////////////////////////////////////////////////////////////////////
                                      SETUP
/////////////////////////////////////////////////////////////////////////////*/


void setup() {

  Serial.begin(115200);

  i2s_driver_install(i2s_num, &i2s_config, 0, NULL);        // ESP32 will allocated resources to run I2S
  i2s_set_pin(i2s_num, &pin_config);  

  IPAddress ip(192, 168, 10, 69); // Set the desired IP address here
  IPAddress gateway(192, 168, 10, 144); // Set the gateway address here
  IPAddress subnet(255, 255, 255, 0); // Set the subnet mask here

  //WIFI Setup
    // Connect to Wi-Fi network with SSID and password
    Serial.print("Connecting to ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
      delay(1000);
      Serial.println("Connecting to WiFi...");
    }

    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    Serial.println(WiFi.localIP());

    WiFi.config(ip, gateway, subnet);
    server.on("/post", handlePost);
    server.begin();

  //Stepper Setup
  A.setMaxSpeed(5000.0);
  B.setMaxSpeed(5000.0);
  A.setCurrentPosition(0.);
  B.setCurrentPosition(0.); 
  A.setAcceleration(1500.);
  B.setAcceleration(1500.);

  //LED pins 
  pinMode(led_G, OUTPUT); 
  pinMode(led_B, OUTPUT); 
  pinMode(led_R, OUTPUT); 

  //Magnet Pin
  pinMode(emag, OUTPUT);
  

  //Limit Switches
  pinMode(limitSwitch_x, INPUT_PULLUP);
  pinMode(limitSwitch_y, INPUT_PULLUP);


  //Initialize Position  
  white(1);
  start = 1;
  initialize();
  move(0,0,homeX,homeY); 
  play(HP_Theme_Data); 
}
  

/*/////////////////////////////////////////////////////////////////////////////
                                      LOOP 
/////////////////////////////////////////////////////////////////////////////*/

void loop() { 
  server.handleClient();
    if(message.length()==6){
    splice = 1;
    spliceMessage() ;
    convert();
    useArray();
    convertCapt(capt);
    chessMove(initX,initY,finX,finY); }
    else if(message.length()==3){
      in = message[0] ;
      if(in=="1" ){
        red(1); 
        play(Exactly_Like_WizChess_Data);
      }
      else if(in=="2"){
        blue(1); 
        play(Yer_A_Wizard_Data);
      }
      else if(in=="3"){
        green(1);
        play(Yer_A_Wizard_Data); 
      }
    }
  message="";   
}
